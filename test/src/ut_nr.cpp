#include <iostream>#include <iomanip>#include <cmath>#include <nr.h>#include <rc_math.h>#include "ut_nr.h"#include <vecLib/clapack.h>#include <rc_time.h>// Driver for routine mrqminUT_nr::UT_nr(){}UT_nr::~UT_nr(){    printSuccessMessage( "Numerical Recipes test", mErrors );}uint32 UT_nr::run(){  // Basic tests  testconvlv ();  testsavgol ();  testMrq2();  testMrq();  testSVD();  return mErrors;}void UT_nr::testconvlv (){        const int N=16;  //data array size        const int M=9;   //response function dim. - must be odd        int i,isign,j;        DP cmp;        Vec_DP data(N),respns(N),resp(M),ans(N);        for (i=0;i<N;i++)          if ((i >= N/2-N/8-1) && (i <= N/2+N/8-1))            data[i]=1.0;          else            data[i]=0.0;        for (i=0;i<M;i++) {          if ((i > 1) && (i < 6))            respns[i]=1.0;          else            respns[i]=0.0;          resp[i]=respns[i];        }        isign=1;        NR::convlv(data,resp,isign,ans);        // compare with a direct convolution        for (i=0;i<N;i++) {          cmp=0.0;          for (j=1;j<=M/2;j++) {            cmp += data[(i-j+N) % N]*respns[j];            cmp += data[(i+j) % N]*respns[M-j];          }          cmp += data[i]*respns[0];	  rcUTCheckRealDelta (ans[i], cmp, 0.01);	          }}void UT_nr::testsavgol (){        const int NMAX=1000,NTEST=1;        const int mtest[NTEST]={2};        const int nltest[NTEST]={2};        const int nrtest[NTEST]={2};        const double ans[5]={-0.086,  0.343,  0.486,  0.343, -0.086};        int i,j,m,nl,np,nr;        DP sum;        Vec_DP c(NMAX);	i = 0;	m=mtest[i];	nl=nltest[i];	nr=nrtest[i];	np=nl+nr+1;	NR::savgol(c,np,nl,nr,0,m);	sum=0.0;	for (j=0;j<np;j++) sum += c[j];	for (j=nl;j>=0;j--,i++)	  {	    rcUTCheckRealDelta (ans[i], c[j], 0.01);	  }	for (j=0;j<nr;j++, i++)	  {	    rcUTCheckRealDelta (ans[i], c[np-1-j], 0.01);	  }	rcUTCheckRealDelta (sum, 1.0, 0.01);}  void UT_nr::testMrq(){  const int NPT=100,MA=6;  const DP SPREAD=0.001;  const DP a_d[MA]={5.0,2.0,3.0,2.0,5.0,3.0};  const DP gues_d[MA]={4.5,2.2,2.8,2.5,4.9,2.8};  int i,j,iter,itst,k,idum=(-911),mfit=MA;  DP alamda,chisq,ochisq;  Vec_BOOL ia(MA);  Vec_DP x(NPT),y(NPT),sig(NPT);  Vec_DP a(a_d,MA),gues(gues_d,MA);  Mat_DP covar(MA,MA),alpha(MA,MA);  // First try a sum of two Gaussians  for (i=0;i<NPT;i++) {    x[i]=0.1*(i+1);    y[i]=0.0;    for (j=0;j<MA;j+=3) {      y[i] += a[j]*exp(-SQR((x[i]-a[j+1])/a[j+2]));    }    y[i] *= (1.0+SPREAD*NR::gasdev(idum));    sig[i]=SPREAD*y[i];  }  for (i=0;i<mfit;i++) ia[i]=true;  for (i=0;i<MA;i++) a[i]=gues[i];  for (iter=0;iter<2;iter++) {    alamda = -1;    NR::mrqmin(x,y,sig,a,ia,covar,alpha,chisq,NR::fgauss,alamda);    k=1;    itst=0;    for (;;) {#if 0      cout << endl << "Iteration #" << setw(3) << k;      cout << setw(18) << "chi-squared:" << setw(13) << chisq;      cout << setw(11) << "alamda:" << setw(10) << alamda << endl;      cout << setw(8) << "a[0]" << setw(9) << "a[1]";      cout << setw(9) << "a[2]" << setw(9) << "a[3]";      cout << setw(9) << "a[4]" << setw(9) << "a[5]" << endl;      cout << fixed << setprecision(6);      for (i=0;i<6;i++) cout << setw(9) << a[i];      cout << endl;#endif      k++;      ochisq=chisq;      NR::mrqmin(x,y,sig,a,ia,covar,alpha,chisq,NR::fgauss,alamda);      fabs(ochisq-chisq) < 0.1 ? itst++ : itst=0;      if (itst < 4) continue;      alamda=0.0;      NR::mrqmin(x,y,sig,a,ia,covar,alpha,chisq,NR::fgauss,alamda);#if 0      cout << endl << "Uncertainties:" << endl;      for (i=0;i<6;i++) cout << setw(9) << sqrt(covar[i][i]);      cout << endl;      cout << endl << "Expected results:" << endl;      cout << setw(9) << 5.0 << setw(9) << 2.0 << setw(9) << 3.0;      cout << setw(9) << 2.0 << setw(9) << 5.0 << setw(9) << 3.0 << endl;#endif      break;    }  }    rcUTCheckRealDelta (a[0], 5.0, 0.1);  rcUTCheckRealDelta (a[1], 2.0, 0.1);  rcUTCheckRealDelta (a[2], 3.0, 0.1);  rcUTCheckRealDelta (a[3], 1.9, 0.1);  rcUTCheckRealDelta (a[4], 5.0, 0.1);  rcUTCheckRealDelta (a[5], 3.0, 0.1);}void UT_nr::testMrq2(){  const int NPT=100,MA=2;  const DP a_d[MA]={4.0, 1.25};  const DP gues_d[MA]={1.0, 0.0};  int i,iter,itst,k,mfit=MA;  DP alamda,chisq,ochisq;  Vec_BOOL ia(MA);  Vec_DP x(NPT),y(NPT),sig(NPT);  Vec_DP a(a_d,MA),gues(gues_d,MA);  Mat_DP covar(MA,MA),alpha(MA,MA);  // First generate a diffusive curve  for (i=0;i<NPT;i++)    {      x[i]=0.01 * (i+1);      y[i]=a[0] * exp (x[i] * a[1]);      sig[i]=1.0;    }  for (i=0;i<mfit;i++) ia[i]=true;  for (i=0;i<MA;i++) a[i]=gues[i];  for (iter=0;iter<1;iter++)    {      alamda = -1;      NR::mrqmin(x,y,sig,a,ia,covar,alpha,chisq,NR::fexponential,alamda);      rcUTCheckRealEq (alamda, 0.01);      k=1;      itst=0;      for (;;)	{#if 0	  	  cout << endl << "Iteration #" << setw(3) << k;	  cout << setw(18) << "chi-squared:" << setw(13) << chisq;	  cout << setw(11) << "alamda:" << setw(10) << alamda << endl;	  cout << setw(8) << "a[0]" << setw(9) << "a[1]";	  cout << fixed << setprecision(6);	  for (i=0;i<MA;i++) cout << setw(9) << a[i];	  cout << endl;#endif	  k++;	  ochisq=chisq;	  NR::mrqmin(x,y,sig,a,ia,covar,alpha,chisq,NR::fexponential,alamda);	  fabs(ochisq-chisq) < 0.01 ? itst++ : itst=0;	  if (itst < 4) continue;	  alamda=0.0;	  NR::mrqmin(x,y,sig,a,ia,covar,alpha,chisq,NR::fexponential,alamda);#if 0	  cout << endl << "Uncertainties:" << endl;	  for (i=0;i<MA;i++) cout << setw(9) << sqrt(covar[i][i]);	  cout << endl;	  cout << endl << "Expected results:" << endl;	  cout << setw(9) << 4.0 << setw(9) << 1.25 << setw(9) << endl;#endif	  break;	}    }  rcUTCheckRealEq (a[0], 4.0);  rcUTCheckRealEq (a[1], 1.25);}void UT_nr::testSVD (){#if 0  // Test SVDCMP against clapack  {        int j,k,l,m,n;	m = 5, n = 3;	Vec_DP w(n);	Mat_DP a(m,n),u(m,n),v(n,n);	// treated with fortran style momory layout (column-wise) and base 1	// ColumnMajorArray would be column wise but base 0	Array<float,2> as (m,n,FortranArray<2>()), us(m,m,FortranArray<2>()), vs(n,n,FortranArray<2>());	Array<float,1> ws (n), work(5*m + 1);	// copy original matrix into u	for (k=0;k<m;k++)	  for (l=0;l<n;l++) {	    a[k][l] = 1 + k + l;	    u[k][l]=a[k][l];	    as(k+1,l+1) = (float) (1 + k + l);	    us(k+1,l+1)=as(k+1,l+1);	  }	rcTime timer;	timer.start ();	for( uint32 i = 0; i < 1; ++i )          NR::svdcmp(u,w,v);	timer.end ();	double dMilliSeconds = timer.milliseconds (); 	fprintf(stderr, "Performance: NR:SVD: %.2f ms (%7.1f Hz) \n", dMilliSeconds, 1000/dMilliSeconds);	  char jobu ('A');	  char jobvt ('A');	  int info;	  int wsize (5 * m + 1);	timer.start ();	for( uint32 i = 0; i < 1; ++i )	  {	    sgesvd_ (&jobu, &jobvt, &m, &n, as.data(), &m, ws.data(),		     us.data(), &m, vs.data(), &n, work.data(), &wsize, &info);	  }	timer.end ();	dMilliSeconds = timer.milliseconds (); 	fprintf(stderr, "Performance: NR:clapack: %.2f ms (%7.1f Hz) \n", dMilliSeconds, 1000/dMilliSeconds);		rcUTCheck (info == 0);	for (k=0;k<n;k++)	  {	    rcUTCheckRealDelta (w[k], ws(k), 0.01f);	  }	for (k=0;k<m;k++) {	  for (l=0;l<n;l++) {	    a[k][l]=0.0;	    as(k+1,l+1)=0.0;	    for (j=0;j<n;j++)	      {		a[k][l] += u[k][j]*w[j]*v[l][j];		as(k+1,l+1) += us(k+1,j+1)*ws(j)*vs(j+1,l+1);	      }	  }	  for (l=0;l<n;l++)	    {	      rcUTCheckRealDelta (a[k][l], as(k+1,l+1), 0.01f);	    }	}  }#endif  const int NPT=100,NPOL=5;  const DP SPREAD=0.002;  int i,idum=(-911);  DP chisq;  Vec_DP x(NPT),y(NPT),sig(NPT),a(NPOL),w(NPOL);  Mat_DP cvm(NPOL,NPOL),u(NPT,NPOL),v(NPOL,NPOL);  //  cout << fixed << setprecision(6);  for (i=0;i<NPT;i++) {    x[i]=0.02*(i+1);    y[i]=1.0+x[i]*(2.0+x[i]*(3.0+x[i]*(4.0+x[i]*5.0)));    y[i] *= (1.0+SPREAD*NR::gasdev(idum));    sig[i]=y[i]*SPREAD;  }  NR::svdfit(x,y,sig,a,u,v,w,chisq,NR::fpoly);  NR::svdvar(v,w,cvm);#if 0  cout << endl << "polynomial fit:" << endl << endl;  for (i=0;i<NPOL;i++) {    cout << setw(12) << a[i] << "  +-";    cout << setw(11) << sqrt(cvm[i][i]) << endl;  }#endif  rcUTCheckRealDelta (a[0], 1.0, 0.1);  rcUTCheckRealDelta (a[1], 2.0, 0.1);  rcUTCheckRealDelta (a[2], 3.0, 0.1);  rcUTCheckRealDelta (a[3], 4.0, 0.1);  rcUTCheckRealDelta (a[4], 5.0, 0.1);#if 0  cout << endl << "Chi-squared " << setw(12) << chisq << endl;#endif  NR::svdfit(x,y,sig,a,u,v,w,chisq,NR::fleg);  NR::svdvar(v,w,cvm); #if 0  cout << endl << "Legendre polynomial fit:" << endl << endl;  for (i=0;i<NPOL;i++) {    cout << setw(12) << a[i] << "  +-";    cout << setw(11) << sqrt(cvm[i][i]) << endl;  }#endif  rcUTCheckRealDelta (a[0], 3.0, 0.1);  rcUTCheckRealDelta (a[1], 4.3, 0.1);  rcUTCheckRealDelta (a[2], 4.9, 0.1);  rcUTCheckRealDelta (a[3], 1.5, 0.1);  rcUTCheckRealDelta (a[4], 1.1, 0.1);#if 0  cout << endl << "Chi-squared " << setw(12) << chisq << endl;#endif  rcUTCheckRealDelta (chisq, 108.0, 0.2);}