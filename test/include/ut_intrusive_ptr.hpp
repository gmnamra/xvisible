//
// Copyright (c) 2006 Alexis Wilke and Doug Barbieri
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//

#include	<intrusive_ptr_object.hpp>
#include	<string>
#include	<iostream>

namespace anonymous
{
    // shows the pointers being created and deleted on the heap
    void *operator new(size_t sz)
    {
        void *p = malloc(sz);
        std::cout << " -- Allocated " << p << " (" << sz << " bytes)" << std::endl;
        return p;
    }
    void operator delete(void *p)
    {
        std::cout << " -- Freeing " << p << std::endl;
        //free(p); -- do not really free so another allocation is at a different address
    }
    
    
    
    
    class A : public boost::intrusive_ptr_base
    {
    public:
        virtual ~A() {}
        void aset(const std::string& s1) { f_s1 = s1; }
        void ainfo() { std::cout << "  A: " << f_s1 << std::endl; }
        
    private:
        std::string f_s1;
    };
    
    
    
    class B : public A
    {
    public:
        B(const std::string& s2) { f_s2 = s2; }
        B() {}
        virtual ~B() {}
        void bset(const std::string& s2) { f_s2 = s2; }
        void binfo() { std::cout << "  B: " << f_s2 << std::endl; }
        
    private:
        std::string f_s2;
    };
    
    // this object (B_heap) is the only one which can be put in
    // an intrusive_ptr<>; however, it is up to you to pay attention
    // and not use B_heap on the stack or as a variable member (duh!)
    typedef boost::intrusive_ptr_heap<B> B_heap;
    
    
    // to allow for the constructor with an std::string we need this
    class B_heap2 : public B, public boost::intrusive_ptr_object
    {
    public:
        B_heap2(const std::string& s2) : B(s2) {}
        B_heap2() {}
    };
    
    
    
    void sub_a(A *a)
    {
        // here we can put A in an intrusive_ptr<>
        boost::intrusive_ptr<A> p(a);
        p->ainfo();
        // auto-release, no delete since ref_count is 1
    }
    
    
    
    void sub_b(B *b)
    {
        // here we can put B in an intrusive_ptr<>
        boost::intrusive_ptr<B> p(b);
        p->binfo();
        // auto-release, no delete since ref_count is 1
    }
    
}

class ut_intrusive
{
    
    int ut_run ()
    {
        {
            // case 1. create B on the stack and try set() + info()
            std::cout << "-----------------------------------" << std::endl;
            std::cout << "Test the stack" << std::endl;
            B b("B on stack");
            b.aset("A on stack");
            //b.bset("B on stack");
            b.ainfo();
            b.binfo();
        }
        {
            // case 2. create B on the heap and try set() + info()
            std::cout << "-----------------------------------" << std::endl;
            std::cout << "Test the heap (1)" << std::endl;
            boost::intrusive_ptr<B> b(new B_heap);
            b->aset("A on heap");
            b->bset("B on heap");
            b->ainfo();
            b->binfo();
            std::cout << "Calling B sub-function" << std::endl;
            sub_b(b.get());
            std::cout << "Calling A sub-function" << std::endl;
            sub_a(b.get());
            // auto-release and thus delete here
        }
        {
            // case 3. create B on the heap and try set() + info()
            std::cout << "-----------------------------------" << std::endl;
            std::cout << "Test the heap (2)" << std::endl;
            boost::intrusive_ptr<B> b(new B_heap2("B on heap"));
            b->aset("A on heap");
            //b->bset("B on heap");
            b->ainfo();
            b->binfo();
            std::cout << "Calling B sub-function" << std::endl;
            sub_b(b.get());
            std::cout << "Calling A sub-function" << std::endl;
            sub_a(b.get());
            // auto-release and thus delete here
        }
        {
            // case 4. invalid case of a stack object used in an intrusive_ptr<>
            std::cout << "Test the stack improperly" << std::endl;
            B b("B on stack");
            b.aset("A on stack");
            //b.bset("B on stack");
            b.ainfo();
            b.binfo();
            std::cout << "Put the stack object in intrusive_ptr<>" << std::endl;
            try {
                boost::intrusive_ptr<B> p(&b);
                std::cerr << "error: The stack object did not generate a crash!?" << std::endl;
            }
            catch(...) {
                // this may not work depending on your compiler which is why this
                // test is done last; if you see 'Segmentation fault' instead
                // then test passed anyway!
                std::cout << "Stack object generated a crash (see dynamic_cast<> in intrusive_ptr_add_ref())" << std::endl;
            }
        }
        
        return 0;
    }
    
}



// vim: ts=4
